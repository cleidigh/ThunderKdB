/*# -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1/GPL 2.0/LGPL 2.1
#
# The contents of this file are subject to the Mozilla Public License Version
# 1.1 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS" basis,
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# for the specific language governing rights and limitations under the
# License.
#
# The Original Code is Mozilla Communicator client code, released
# March 31, 1998.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998-1999
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Joachim Herb <joachim.herb@gmx.de>
#
# Alternatively, the contents of this file may be used under the terms of
# either the GNU General Public License Version 2 or later (the "GPL"), or
# the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
# in which case the provisions of the GPL or the LGPL are applicable instead
# of those above. If you wish to allow use of your version of this file only
# under the terms of either the GPL or the LGPL, and not to allow others to
# use your version of this file under the terms of the MPL, indicate your
# decision by deleting the provisions above and replace them with the notice
# and other provisions required by the GPL or the LGPL. If you do not delete
# the provisions above, a recipient may use your version of this file under
# the terms of any one of the MPL, the GPL or the LGPL.
#
# ***** END LICENSE BLOCK *****
*/

if (typeof org_mozdev_AutoSlide == "undefined") {
  var org_mozdev_AutoSlide = {};
};

org_mozdev_AutoSlide.slider = function() {
  var pub = {};

  Cu.import("resource://gre/modules/Services.jsm");

  var ASPrefBranch = Components.classes["@mozilla.org/preferences-service;1"]
                                        .getService(Components.interfaces.nsIPrefService)
                                        .getBranch("extensions.AutoSlide.");
//  var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"]
//                                           .getService(Components.interfaces.nsIConsoleService);
//
//  const { console } = Components.utils.import("resource://gre/modules/devtools/Console.jsm", {});

  /**
   * Defines the DBViewWrapper listener interface.  This class exists exclusively
   *  for documentation purposes and should never be instantiated.
   */
  function viewWrapperListener() {
  }

  viewWrapperListener.prototype = {
    /* ===== Event Notifications ===== */
    /* === Status Changes === */
    /**
     * We tell you when we start and stop loading the folder.  This is a good
     *  time to mess with the hour-glass cursor machinery if you are inclined to
     *  do so.
     */
//    onFolderLoading: function (aIsFolderLoading) {
//      debugLog("onFolderLoading");
//    },

    /**
     * We tell you when we start and stop searching.  This is a good time to mess
     *  with progress spinners (meteors) and the like, if you are so inclined.
     */
//    onSearching: function (aIsSearching) {
//      debugLog("onSearching");
//    },

    /**
     * This event is generated when a new view has been created.  It is intended
     *  to be used to provide the MsgCreateDBView notification so that custom
     *  columns can add themselves to the view.
     * The notification is not generated by the DBViewWrapper itself because this
     *  is fundamentally a UI issue.  Additionally, because the MsgCreateDBView
     *  notification consumers assume gDBView whose exposure is affected by tabs,
     *  the tab logic needs to be involved.
     */
//    onCreatedView: function() {
//      debugLog("onCreatedView");
//    },

    /**
     * This event is generated just before we close/destroy a message view.
     *
     * @param aFolderIsComingBack Indicates whether we are planning to create a
     *     new view to display the same folder after we destroy this view.  This
     *     will be the case unless we are switching to display a new folder or
     *     closing the view wrapper entirely.
     */
//    onDestroyingView: function(aFolderIsComingBack) {
//      debugLog("onDestroyingView");
//    },

    /**
     * Generated when we are loading information about the folder from its
     *  dbFolderInfo.  The dbFolderInfo object is passed in.
     * The DBViewWrapper has already restored its state when this function is
     *  called, but has not yet created the dbView.  A view update is in process,
     *  so the view settings can be changed and will take effect when the update
     *  is closed.
     * |onDisplayingFolder| is the next expected notification following this
     *  notification.
     */
//    onLoadingFolder: function(aDbFolderInfo) {
//      debugLog("onLoadingFolder");
//    },

    /**
     * Generated when the folder is being entered for display.  This is the chance
     *  for the listener to affect any UI-related changes to the folder required.
     *  Currently, this just means setting the header cache size (which needs to
     *  be proportional to the number of lines in the tree view, and is thus a
     *  UI issue.)
     * The dbView has already been created and is valid when this function is
     *  called.
     * |onLoadingFolder| is called before this notification.
     */
//    onDisplayingFolder: function() {
//      debugLog("onDisplayingFolder");
//    },

    /**
     * Generated when we are leaving a folder.
     */
//    onLeavingFolder: function() {
//      debugLog("onLeavingFolder");
//    },

    /**
     * Things to do once all the messages that should show up in a folder have
     *  shown up.  For a real folder, this happens when the folder is entered.
     *  For a (multi-folder) virtual folder, this happens when the search
     *  completes.
     * You may get onMessagesLoaded called with aAll false immediately after
     * the view is opened. You will definitely get onMessagesLoaded(true)
     * when we've finished getting the headers for the view.
     */
    onMessagesLoaded: function(aAll) {
      debugLog("onMessagesLoaded slide");
      pub.delayedSlideSlow();
    },

    /**
     * The mail view changed.  The mail view widget is likely to care about this.
     */
//    onMailViewChanged: function() {
//      debugLog("onMailViewChanged");
//    },

    /**
     * The active sort changed, and that is all that changed.  If the sort is
     *  changing because the view is being destroyed and re-created, this event
     *  will not be generated.
     */
//    onSortChanged: function() {
//      debugLog("onSortChanged");
//    },

    /**
     * This event is generated when messages in one of the folders backing the
     *  view have been removed by message moves / deletion.  If there is a search
     *  in effect, it is possible that the removed messages were not visible in
     *  the view in the first place.
     */
//    onMessagesRemoved: function () {
//      debugLog("onMessagesRemoved");
//    },

    /**
     * Like onMessagesRemoved, but something went awry in the move/deletion and
     *  it failed.  Although this is not a very interesting event on its own,
     *  it is useful in cases where the listener was expecting an
     *  onMessagesRemoved and might need to clean some state up.
     */
//    onMessageRemovalFailed: function () {
//      debugLog("onMessageRemovalFailed");
//    },

    /**
     * The total message count or total unread message counts changed.
     */
//    onMessageCountsChanged: function () {
//      debugLog("onMessageCountsChanged");
//    },

//    onActiveCreatedView: function() {
//      debugLog("onActiveCreatedView");
//    },

//    onMakeActive: function() {
//      debugLog("onMakeActive");
//    }
  };

  var timerSlow;
  var timerFast;

  function debugLog(str) {
    if (ASPrefBranch.getBoolPref("debugLog")) {
//      aConsoleService.logStringMessage(Date() + " AS: " + str);
      Services.console.logStringMessage(Date() + " AS: " + str);
      //      console.log(Date() + " AS: " + str);
    }
  }

  pub.init = function () {
    debugLog("AS init start");
    var mailSession = Components.classes["@mozilla.org/messenger/services/session;1"]
                                .getService(Components.interfaces.nsIMsgMailSession);
    var nsIFolderListener = Components.interfaces.nsIFolderListener;
    mailSession.AddFolderListener(folderListener, nsIFolderListener.removed |
                                                  nsIFolderListener.added |
                                                  nsIFolderListener.event);

    document.defaultView.FolderDisplayListenerManager.registerListener(new viewWrapperListener());

    var observerService = Components.classes["@mozilla.org/observer-service;1"]
                                  .getService(Components.interfaces.nsIObserverService);
    observerService.addObserver(msgObserver, "MsgMsgDisplayed", false);

    myPrefObserver.register();

    var threadTree = document.getElementById("threadTree");
    threadTree.addEventListener("click", onCollapseChange);

    var multiMessage = document.getElementById("multimessage");
    if (multiMessage){
      debugLog("multimessage ...");
      multiMessage.contentDocument.addEventListener("load", onCollapseChange, true);
      debugLog("multimessage added");
    }

    var threadPaneSplitter = document.getElementById("threadpane-splitter");
    threadPaneSplitter.addEventListener("dblclick", pub.slideForce);
    threadPaneSplitter.addEventListener("contextmenu", pub.toggleSlide);

    var tpsPersist = threadPaneSplitter.getAttribute("persist");
    debugLog("tpsPersist "+tpsPersist);
    if (!tpsPersist || !(new RegExp('\\bautoslideoff\\b').test(tpsPersist))) {
      threadPaneSplitter.setAttribute("persist", tpsPersist + " autoslideoff ");
    }

    let threadToggle = ["cmd_expandAllThreads", "cmd_collapseAllThreads"];

    for (let i = 0; i < threadToggle.length; i++) {
      let cmd = document.getElementById(threadToggle[i]);
      if (cmd) {
        cmd.addEventListener("command", onCollapseChange);
        debugLog("add command event: " + cmd.id);
      }
    }

    let mailKeys = document.getElementById("mailKeys");
    let keys = mailKeys.getElementsByAttribute("oncommand", "goDoCommand('cmd_expandAllThreads')");
    for (let i = 0; i < keys.length; i++) {
      if (keys[i]) {
        keys[i].addEventListener("command", onCollapseChange);
        debugLog("add key event: " + keys[i].id);
      }
    }
    keys = mailKeys.getElementsByAttribute("oncommand", "goDoCommand('cmd_collapseAllThreads')");
    for (let i = 0; i < keys.length; i++) {
      if (keys[i]) {
        keys[i].addEventListener("command", onCollapseChange);
        debugLog("add key event: " + keys[i].id);
      }
    }

    timerSlow = Components.classes["@mozilla.org/timer;1"]
                                   .createInstance(Components.interfaces.nsITimer);
    timerFast = Components.classes["@mozilla.org/timer;1"]
                                   .createInstance(Components.interfaces.nsITimer);
  };

  var msgObserver = {
    observe: function (aSubject, aTopic, aData) {
      debugLog("msgObserver " + aTopic);
      debugLog("msgObserver slide");
      pub.delayedSlideFast();
    }
  };

  function onCollapseChange() {
    debugLog("onCollapseChange ");
    pub.delayedSlideFast();
  };

  function onThreadTreeChange(event) {
    debugLog("onThreadTreeChange " + event.attrName);
  };

  var delayedSlideRequestSlow = false;
  var delayedSlideRequestFast = false;

  var eventSlow = {
    notify: function(timer) {
      debugLog("delayedSlideSlow start");
      pub.slide();
      delayedSlideRequestSlow = false;
      debugLog("delayedSlideSlow stop");
    }
  };

  var eventFast = {
      notify: function(timer) {
        debugLog("delayedSlideFast start");
        pub.slide();
        delayedSlideRequestFast = false;
        debugLog("delayedSlideFast stop");
      }
    };


  pub.delayedSlideSlow = function () {
    debugLog("delayedSlideSlow issued 1");
    if (!delayedSlideRequestSlow) {
      debugLog("delayedSlideSlow issued 2");
      delayedSlideRequestSlow = true;
      timerSlow.initWithCallback(eventSlow, 500, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
    }
  }

  pub.delayedSlideFast = function () {
    debugLog("delayedSlideFast issued 1");
    if (!delayedSlideRequestFast) {
      debugLog("delayedSlideFast issued 2");
      delayedSlideRequestFast = true;
      timerFast.initWithCallback(eventFast, 50, Components.interfaces.nsITimer.TYPE_ONE_SHOT);
    }
  }

  pub.toggleSlide = function () {
    debugLog("toggleSlide");
    var threadPaneSplitter = document.getElementById("threadpane-splitter");
    var slideState = threadPaneSplitter.getAttribute("autoslideoff");
    if (slideState) {
      threadPaneSplitter.removeAttribute("autoslideoff");
    }
    else {
      threadPaneSplitter.setAttribute("autoslideoff", "true");
    }
  }

  pub.slideForce = function() {
    pub.slide(true);
  }

  pub.slide = function(force) {
    var currentTabInfo = document.getElementById("tabmail").currentTabInfo;
    if ((currentTabInfo.mode.name != "folder") &&
        (currentTabInfo.mode.name != "glodaList")) {
      //debugLog("not in folder");
      return;
    }
    if (gDBView==null) {
      return;
    }

    //var test = gFolderDisplay.displayedFolder;
    //var test2 = gFolderDisplay.displayedFolder.URI;
    var tree = document.getElementById("threadTree");
    var treeBox = tree.boxObject;
    var treeView = gDBView.QueryInterface(Components.interfaces.nsITreeView);

    var threadPaneSplitter = document.getElementById("threadpane-splitter");
    var threadPaneSplitterBox = threadPaneSplitter.boxObject;

    if ((threadPaneSplitter.getAttribute("state") == "collapsed") ||
        ((threadPaneSplitter.getAttribute("autoslideoff")) &&
         (!force))) {
      return;
    }
    var messagePaneBox = document.getElementById("messagepaneboxwrapper");
    messagePaneBox.setAttribute("flex", "0");

    var treeView = gDBView.QueryInterface(Components.interfaces.nsITreeView);
    var count = treeView.rowCount;
    //debugLog(treeBox.getPageLength() + " of " + count);

    var minHeightPercent = ASPrefBranch.getIntPref("maxThreadPanePercentage");

    var requiredHeight = tree.rowHeight * count;
    var setHeight;

    var oldHeight = treeBox.height - document.getElementById("threadCols").boxObject.height - 1;
    var displayDeck = document.getElementById("displayDeck");
    var oldDisplayDeckHeight = displayDeck.boxObject.height;
    debugLog("treeBox: " + treeBox);
    debugLog("tree.getPageLength(): " + tree.getPageLength());
    debugLog("minHeightPercent: " + minHeightPercent);
    debugLog("treeBox: " + treeBox.rowHeight);
    debugLog("count: " + count);
    debugLog("oldHeight: " + oldHeight);
    debugLog("requiredHeight: " + requiredHeight);
    var deltaHeight = requiredHeight - oldHeight;

    var messagesBoxBox = document.getElementById("messagesBox").boxObject;

    var newSplitterY = threadPaneSplitterBox.y +
                       deltaHeight;

    oldHeight = messagePaneBox.boxObject.height;
    messagePaneBox.removeAttribute("height");

    var minSplitterY = messagesBoxBox.y +
                       messagesBoxBox.height * minHeightPercent/100.0;

    debugLog("threadPaneSplitterBox: " + threadPaneSplitterBox.y);
    debugLog("deltaHeight: " + deltaHeight);
    debugLog("deltaHeight: " + deltaHeight);
    debugLog("newSplitterY: " + newSplitterY);
    debugLog("messagesBoxBoxY: " + messagesBoxBox.y);
    debugLog("messagesBoxBoxHeight: " + messagesBoxBox.height);
    debugLog("minSplitterY: " + minSplitterY);
    debugLog("old delta: " + deltaHeight);

    if (newSplitterY > minSplitterY) {
      deltaHeight = deltaHeight + (minSplitterY - newSplitterY);
    }
    debugLog("new delta: "+deltaHeight);


    var anotherDelta = oldDisplayDeckHeight + deltaHeight - displayDeck.getAttribute("minheight");
    if (anotherDelta < 0) {
      deltaHeight = deltaHeight - anotherDelta;
    }

    var newHeight = oldHeight - deltaHeight;
    debugLog("old: "+oldHeight + " new: "+newHeight);

    messagePaneBox.setAttribute("height", newHeight);
    displayDeck.setAttribute("height", displayDeck.boxObject.height);

    messagePaneBox.setAttribute("flex", "1");
    var messagePaneHBox = document.getElementById("messagepanehbox")
    if (messagePaneHBox) {
      messagePaneHBox.removeAttribute("height");
    }
  };

  var folderListener = {

    OnItemAdded: function(aParentItem, aItem) {
      var currentFolder = gFolderTreeView.getSelectedFolders()[0];
      if (aParentItem == currentFolder) {
        //debugLog("added " + aParentItem + " " + aItem);
        debugLog("OnItemAdded slide");
        pub.delayedSlideFast();
      }
    },
    OnItemRemoved: function(aParentItem, aItem) {
      var currentFolder = gFolderTreeView.getSelectedFolders()[0];
      if (aParentItem == currentFolder) {
        //debugLog("deleted" + aParentItem + " " + aItem);
        debugLog("OnItemRemoved slide");
        pub.delayedSlideFast();
      }
    },
    OnItemEvent: function(aItem, aEvent) {
      //debugLog("event " +" " + aEvent);
      debugLog("OnItemEvent slide");
      pub.delayedSlideFast();
    },

  };

  var myPrefObserver =
  {
    register: function()
    {
      // First we'll need the preference services to look for preferences.
      var prefService = Components.classes["@mozilla.org/preferences-service;1"]
                                  .getService(Components.interfaces.nsIPrefService);

      // For this._branch we ask that the preferences for extensions.myextension. and children
      this._branch = prefService.getBranch("extensions.AutoSlide.");

      // Now we queue the interface called nsIPrefBranch2. This interface is described as:
      // "nsIPrefBranch2 allows clients to observe changes to pref values."
      this._branch.QueryInterface(Components.interfaces.nsIPrefBranch);

      // Finally add the observer.
      this._branch.addObserver("", this, false);
    },

    unregister: function()
    {
      if(!this._branch) return;
      this._branch.removeObserver("", this);
    },

    observe: function(aSubject, aTopic, aData)
    {
      if(aTopic != "nsPref:changed") return;
      // aSubject is the nsIPrefBranch we're observing (after appropriate QI)
      // aData is the name of the pref that's been changed (relative to aSubject)
      debugLog("myPrefObserver slide");
      pub.delayedSlideFast();
    }
  }

  return pub;
}();

addEventListener("load", org_mozdev_AutoSlide.slider.init, true);

