{"version":3,"sources":["webpack://changelogger/./node_modules/webextension-polyfill-ts/lib/index.js","webpack://changelogger/external \"browser\"","webpack://changelogger/webpack/bootstrap","webpack://changelogger/./src/OptionsInterface.ts","webpack://changelogger/./src/background.ts","webpack://changelogger/./src/Semaphore.ts","webpack://changelogger/./src/AMO/getDetails.ts"],"names":["exports","browser","module","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","Options","opts","_a","_b","_c","_d","this","badge","notification","max","ignore_no_changelogs","STORAGE_SEMAPHORE","lock","waitlist","Promise","resolve","reject","push","length","shift","async","getChangelog","info","installType","id","options","details","requestURL","URL","pathname","searchParams","append","res","fetch","href","status","json","getDetails","version","current_version","releaseNotes","release_notes","item","icon","icon_url","split","name","url","getLock","changelogs","filter","clItem","unshift","pop","releaseLock","type","title","message","iconUrl","text","console","log","reason","manifest"],"mappings":"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","file":"background.bundle.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.browser = require(\"webextension-polyfill\");\n","module.exports = browser;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export class Options {\n    constructor(opts) {\n        var _a, _b, _c, _d;\n        opts = opts !== null && opts !== void 0 ? opts : {};\n        this.badge = (_a = opts.badge) !== null && _a !== void 0 ? _a : true;\n        this.notification = (_b = opts.notification) !== null && _b !== void 0 ? _b : true;\n        this.max = (_c = opts.max) !== null && _c !== void 0 ? _c : 10;\n        this.ignore_no_changelogs = (_d = opts.ignore_no_changelogs) !== null && _d !== void 0 ? _d : false;\n    }\n}\n","import { Semaphore } from \"./Semaphore\";\nimport { browser } from \"webextension-polyfill-ts\";\nimport { getDetails } from \"./AMO/getDetails\";\nimport { Options } from \"./OptionsInterface\";\nconst STORAGE_SEMAPHORE = new Semaphore();\n/**\n * Runs on install to initialize settings\n * @param info Install details\n */\nasync function setup(info) {\n    const resLocal = await browser.storage.local.get();\n    if (info.reason === \"install\" || info.reason === \"update\") {\n        const manifest = browser.runtime.getManifest();\n        getChangelog({\n            name: manifest.name,\n            id: \"changelogger@r01\",\n            version: manifest.version\n        });\n    }\n}\n/**\n * Gets the changelog for an installed extension from AMO and stores it.\n * Will create a notification, update badge if those respective options are enabled.\n * @param info Info about an installed extension from Management\n */\nasync function getChangelog(info) {\n    var _a;\n    if (info.installType === \"development\") {\n        return;\n    }\n    if (info.id === undefined) {\n        return;\n    }\n    const opts = new Options((await browser.storage.local.get()).options);\n    const details = await getDetails(info.id);\n    if (details === null) {\n        console.log(\"Could not find extension %s\", info.id);\n        return;\n    }\n    if (info.version === details.current_version.version) {\n        let releaseNotes;\n        if (details.current_version.release_notes === null) {\n            if (opts.ignore_no_changelogs) {\n                return;\n            }\n            releaseNotes = browser.i18n.getMessage(\"noChangelog\");\n        }\n        else {\n            releaseNotes = details.current_version.release_notes;\n        }\n        const item = {\n            id: info.id,\n            version: details.current_version.version,\n            icon: details.icon_url.split(\"?\")[0],\n            name: details.name,\n            release_notes: releaseNotes,\n            url: details.url\n        };\n        // Request access to critical region\n        // Block until available\n        await STORAGE_SEMAPHORE.getLock();\n        // console.log(\"enter critical region\");\n        // Get changelogs\n        // Default to [] if not initialized\n        // Filter all items with the same id and version\n        const changelogs = ((_a = (await browser.storage.local.get()).changelogs) !== null && _a !== void 0 ? _a : [])\n            .filter((clItem) => clItem.id !== item.id || clItem.version !== item.version);\n        // Add current changelog to list\n        changelogs.unshift(item);\n        /// Remove excess changelogs\n        while (changelogs.length > opts.max) {\n            changelogs.pop();\n        }\n        await browser.storage.local.set({ changelogs });\n        // Release critical region\n        // Changelog list in storage.local should not be updated after this point\n        // console.log(\"exit critical region\");\n        STORAGE_SEMAPHORE.releaseLock();\n        if (opts.notification) {\n            browser.notifications.create({\n                type: \"basic\",\n                title: browser.i18n.getMessage(\"updateTitle\", [info.name, info.version]),\n                message: item.release_notes,\n                iconUrl: item.icon\n            });\n        }\n        if (opts.badge) {\n            browser.browserAction.setBadgeText({ text: \"!\" });\n        }\n    }\n}\nbrowser.management.onInstalled.addListener(getChangelog);\nbrowser.runtime.onInstalled.addListener(setup);\n","/**\n * A semaphore implementation in JS\n *\n * A semaphore object should be assigned to a critical region.\n *\n * When a function would like to access the critical region, it should call `semaphore.getLock()`.\n * If the lock is free, it will obtain the lock in the form of a resolved promise.\n * If the lock is not free, it will be added to a waitlist and be given an unresolved promise,\n * and should wait for the promise to resolve before accessing the critical region.\n *\n * When you are done with a critical region, you should release the lock with `semaphore.releaseLock()`.\n * This will resolve the promise given to the next function on the waitlist, giving it the lock.\n *\n * If you don't release the lock when you're done, the functions on the waitlist will starve!\n *\n * When the last function on the waitlist releases its lock, the lock will be free again.\n */\nexport class Semaphore {\n    constructor() {\n        this.lock = false;\n        this.waitlist = [];\n    }\n    /**\n     * Requests to get the lock.\n     * If the lock is available, a resolved promise will be returned.\n     * If the lock is not available yet, a pending promise will be returned to\n     * be resolved when the lock is available.\n     */\n    getLock() {\n        if (!this.lock) {\n            this.lock = true;\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.waitlist.push({ resolve, reject });\n            });\n        }\n    }\n    /**\n     * Release the lock and give it to the next item on the waitlist.\n     * You should release the lock after finishing with the critical region\n     * to avoid starving the items on the waitlist.\n     */\n    releaseLock() {\n        var _a;\n        if (this.lock) {\n            if (this.waitlist.length === 0) {\n                this.lock = false;\n                return;\n            }\n            (_a = this.waitlist.shift()) === null || _a === void 0 ? void 0 : _a.resolve();\n        }\n    }\n}\n","import { browser } from \"webextension-polyfill-ts\";\n/**\n * Get details about an addon from AMO.\n * @param id The ID of the extension. `null` will be returned if this is not a valid ID.\n */\nexport async function getDetails(id) {\n    if (id === undefined) {\n        return null;\n    }\n    const requestURL = new URL(\"https://addons.thunderbird.net/api/v4/addons/addon\");\n    requestURL.pathname += \"/\" + id;\n    requestURL.searchParams.append(\"lang\", browser.i18n.getUILanguage());\n    const res = await fetch(requestURL.href);\n    if (res.status >= 200 && res.status <= 299) {\n        return await res.json();\n    }\n    else {\n        return null;\n    }\n}\n"],"sourceRoot":""}